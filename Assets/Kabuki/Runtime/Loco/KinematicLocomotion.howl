âŠ Ex = System.Exception;
âŠ UnityEngine; âŠÌ¥ UnityEngine.Time; âŠÌ¥ UnityEngine.Mathf;
âŠ Active.Core; âŠÌ¥ Active.Status; âŠ Active.Util;
âŠ Activ.Kabuki;

âŠ“ Active.Loco{
â€’ â—‹ KinematicLocomotion : Locomotion{

    Active.Core.Details.LogString log = âˆ…;
    TVec3 direction;
    Transform transform;
    XTask actor;

    // TODO: actor is only needed for animation playback
    â€’ KinematicLocomotion(ã‚¨ t, XTask actor){
        ã¿ = t;
        â¦¿.actor = actor;
    }

    â€’ â‘‚ Idle() â†’ â˜¡;

    â€’ â‘‚ MoveTo(ãƒ¡ â—, ã…… speed){
        â¤´ (ã¿Ë™ â˜° â—) â—‡Ì 
        ã…… d = ã¿.PlanarDist(â—), Î´ = ğ›¿ğš á§ ğ‡;
        â® (Î´ > d) ? Do(ã¿Ë™ = â—) : DoMove(ã¿.PlanarDir(â—), Î´, d);
    }

    â€’ â‘‚ MoveTo(ã‚¨ â—, ã…… speed){
        â¤´ (ã¿Ë™ â˜° â—Ë™) â—‡Ì 
        ã…… d = ã¿.PlanarDist(â—), Î´ = ğ›¿ğš á§ ğ‡;
        â® (Î´ > d) ? Do(ã¿Ë™ = â—Ë™) : DoMove(ã¿.PlanarDir(â—), Î´, d);
    }

    â€’ â‘‚ MoveTowards(ãƒ¡ â—, ã…… dist, ã…… speed){
        ã…… d = ã¿.PlanarDist(â—);
        â®  (d < dist) âˆ¨ DoMove(ã¿.PlanarDir(â—), ğ›¿ğš á§ ğ‡, d);
    }

    â€’ â‘‚ MoveTowards(ã‚¨ â—, ã…… dist, ã…… speed){
        //ebug.Log($"Move towards {target}, dist:{dist}, speed:{speed} @{Time.frameCount}");
        ã…… d = ã¿.PlanarDist(â—);
        â®  (d < dist) âˆ¨ DoMove(ã¿.PlanarDir(â—), ğ›¿ğš á§ ğ‡, d, ignore: â—);
    }

    â€’ â‘‚ Move(ã‚· u, ã…… speed, ã…… los)
        â†’ DoMove(u.X_Z()Â¹, ğ›¿ğš á§ ğ‡, los);

    // --------------------------------------------------------------

    â‘‚ DoMove(ã‚· u, ã…… Î´, ã…… los, ã‚¨ ignore=âˆ…){
        ã‚·? v = direction;
        // Avoidance vector is valid for one second at most; this
        // avoids dithering. Here the avoidance vector expired;
        // regenerate it.
        â¤´ (v â˜° âˆ…){
            direction = Avoidance.Clear(ã¿Ë™, u, maxDistance: los,
                                                ignore: ignore);
            v = direction;
        }
        // If no valid direction was found, return fail
        â¤´ (v â˜° âˆ…){
            actor.Play("Idle");
            â® â– [log âˆ§ $"No avoidance vec @{Time.time:#.#}"];
        }
        // Since we don't always regen an avoidance vector, sometimes
        // The current vector is invalid (ie, on a collision course).
        // Then we return cont as we're just going to yield for a bit.
        â¤´ (!Avoidance.HasClearLOS(ã¿Ë™, vá–¾, Mathf.Min(1f, los),
                                                             ignore)){
            actor.Play("Idle");
            â® â– [log âˆ§ "Collision course (avoid vec out of date)"];
        }
        // TODO: after lerp we may still be on a collision course.
        // this is not taken into account.
        ã¿.â«« = ã‚·.Lerp(ã¿.â««, vá–¾, 0.1f);
        // If orientation is lagging behind catch-up first, no
        // location update
        â¤´ (ã‚·.Angle(ã¿.â««, vá–¾) > 10f) â˜¡Ì±
        // Update position
        actor.Play("Walk");
        â® Cont(ã¿Ë™ += vá–¾ á§ Î´);
    }

    â”ˆ Print(âŠ¡ arg) â†’ UnityEngine.Debug.Log(arg);

}}
