âŠ System; âŠ UnityEngine; âŠ Active.Core; âŠÌ¥ Active.Status;
âŠ Activ.Kabuki; âŠ Active.Util;

âŠ“ Active.Loco{
â€’ â—‹ PhysicalLocomotion : Activ.Kabuki.XTask, Locomotion{

    â€’ Motor motor = âŒ¢ Motor();
    â€’ Rotor rotor = âŒ¢ Rotor();
    â€’ ã…‡ setupCapsule = âœ“;
    LocoTask @delegate;
    int cframe;

    Avoidance2 avoidance = âŒ¢ Avoidance2();
    â‘‚ state;

    â”ˆ Awake(){
        â¤´ (setupCapsule)CapsuleBuilder.BuildAndResize(ã¿);
        âˆ™ rb = â§¼Rigidbodyâ§½;
        â¤´ (!rb){
            rb =ã€ŠRigidbodyã€‹;
            rb.mass = 50;
            rb.constraints = RigidbodyConstraints.FreezeRotationX
                           | RigidbodyConstraints.FreezeRotationZ;

        }
    }

    â€’ â‘‚ Idle(){
        cframe = Time.frameCount;
        @delegate = âŒ¢ Stopping(); â˜¡Ì±
    }

    // <Locomotion>
    â€’ â‘‚ Move(ã‚· u, ã…… speed, ã…… los) â†’ Steer(u, ğ‡, los);

    â€’ â‘‚ Steer(ã‚· â—, ã…… speed, ã…… maxDist = 3f){
        cframe = Time.frameCount;
        ã‚· direction = â—;
        â‘‚ av = avoidance.Correct(ã¿, ref direction, maxDist);
        â¤´ (av.failing){
            direction = ã‚·.zero;
            â¤´ (!(@delegate is Stopping)) @delegate = âŒ¢ Stopping();
            â® â– [log âˆ§ "No clear course"];
        }â¤µ{
            ã…‡ changed = âœ—;
            â¤´ (!(@delegate is Steering)){
                @delegate = âŒ¢ Steering(); changed = âœ“;
            }
            changed |= (@delegate as Steering).Update(direction, ğ‡);
            â® changed ? â˜¡ : state;
        }
    }

    // <Locomotion>
    // NOTE: do not modify state when done (no idle stance/animation)
    â€’ â‘‚ MoveTowards(ãƒ¡ â—, ã…… dist, ã…… speed)
        â†’ (ã¿.Dist(â—) â‰¤ dist) âˆ¨ MoveTo(â—, ğ‡);

    â€’ â‘‚ MoveTowards(ã‚¨ â—, ã…… dist, ã…… speed){
        //ebug.Log($"(Physics) Move towards {target}, dist:{dist}, speed:{speed} @{Time.frameCount}");
        â® (ã¿.Dist(â—) â‰¤ dist) âˆ¨ MoveTo(â—Ë™, ğ‡, â—);
    }

    // <Locomotion>
    â€’ â‘‚ MoveTo(ãƒ¡ â—, ã…… speed) â†’ MoveTo(â—, ğ‡, âˆ…);

    â€’ â‘‚ MoveTo(ãƒ¡ â—, ã…… speed, ã‚¨ ignore){
        // We're going to check first whether we can move towards
        // the target.
        cframe = Time.frameCount;
        ã‚· u0 = ã¿.Dir(â—, planar: âœ“);
        ã‚· u = u0;
        â‘‚ av = avoidance.Correct(ã¿, ref u, ã¿.Dist(â—), ignore);
        â¤´ (av.failing){
            â¤´ (!(@delegate is Stopping)) @delegate = âŒ¢ Stopping();
            â® â– [log âˆ§ "No clear course"];
        }
        ã…‡ changed = âœ—;
        // Now uh... this is a little tricky. If we have an
        // avoidance vector then we probably should not want the
        // homing delegate. Otherwise we use that.
        â¤´ (u â˜° u0){
            â¤´ (!(@delegate is Homing)){
                @delegate = âŒ¢ Homing(); changed = âœ“;
            }
            changed |= (@delegate as Homing).Update(â—, ğ‡);
            â® changed ? â˜¡ : state;
        }â¤µ {
            â¤´ (!(@delegate is Steering)){
                @delegate = âŒ¢ Steering(); changed = âœ“;
            }
            changed |= (@delegate as Steering).Update(u, ğ‡);
            â® changed ? â˜¡ : state;
        }
    }

    âºâ€’ â‘‚ Step(){
        â¤´ (Time.frameCount > cframe + 1) â—‡Ì 
        â¤´ (!grounded){
            Play("Flail");
            â® state = â– [log âˆ§ "Not grounded"]; }
        Play("Walk");
        â® Îµ(state = @delegate â‰  âˆ… ? @delegate.Step(â¦¿)
                                   : â– [log âˆ§ "No delegate"]);
    }

    ã…‡ grounded{ â•­{
        âˆ™ P = shape.bounds.center;
        âˆ™ h = shape.bounds.extents.y * 1.1f;
        RaycastHit hit;
        ã…‡ didHit = Physics.Raycast(P, ã‚·.âŠ¤, out hit, h);
        â® didHit;
    }}

    â€’ Collider  shape â†’ â§¼Colliderâ§½;
    â€’ Rigidbody body  â†’ â§¼Rigidbodyâ§½;

}}
