⊐ Ex = System.Exception;
⊐ UnityEngine; ⊐̥ UnityEngine.Time; ⊐̥ UnityEngine.Mathf;
⊐ Active.Core; ⊐̥ Active.Status;

⊓ Activ.Kabuki{ ‒ ○ Locomotion{

    Active.Core.Details.LogString log = ∅;
    TVec3 direction;

    ‒ ⑂ MoveTo(エ x, メ y, ㅅ speed){
        ⤴ (x˙ ☰ y) ◇̠
        ㅅ d = x.PlanarDist(y), δ = 𝛿𝚝 ᐧ 𝝇;
        ⮐ (δ > d) ? Do( x˙ = y) : DoMove(x, x.PlanarDir(y), δ, d);
    }

    ‒ ⑂ MoveTowards(エ x, メ y, ㅅ dist, ㅅ speed){
        ㅅ d = x.PlanarDist(y);
        ⮐  (d < dist) ∨ DoMove(x, x.PlanarDir(y), 𝛿𝚝 ᐧ 𝝇, d);
    }

    ‒ ⑂ MoveTowards(エ x, エ y, ㅅ dist, ㅅ speed){
        ㅅ d = x.PlanarDist(y);
        ⮐  (d < dist) ∨ DoMove(x, x.PlanarDir(y), 𝛿𝚝 ᐧ 𝝇, d);
    }

    ‒ ⑂ Move(エ み, シ u, ㅅ speed, ㅅ los)
        → DoMove(み, u.X_Z()¹, 𝛿𝚝 ᐧ 𝝇, los);

    // --------------------------------------------------------------

    ⑂ DoMove(エ み, シ u, ㅅ δ, ㅅ los){
        シ? v = direction;
        // Avoidance vector is valid for one second at most; this
        // avoids dithering. Here the avoidance vector expired;
        // regenerate it.
        ⤴ (v ☰ ∅){
            direction = Avoidance.Clear(み˙, u, maxDistance: los);
            v = direction;
        }
        // If no valid direction was found, return fail
        ⤴ (v ☰ ∅){
            ⮐ ■[log ∧ $"No avoidance vec @{Time.time:#.#}"];
        }
        // Since we don't always regen an avoidance vector, sometimes
        // The current vector is invalid (ie, on a collision course).
        // Then we return cont as we're just going to yield for a bit.
        ⤴ (!Avoidance.HasClearLOS(み˙, vᖾ, Mathf.Min(1f, los))){
            ⮐ ■[log ∧ "Collision course (avoid vec out of date)"];
        }
        // TODO: after lerp we may still be on a collision course.
        // this is not taken into account.
        み.⫫ = シ.Lerp(み.⫫, vᖾ, 0.1f);
        // If orientation is lagging behind catch-up first, no
        // location update
        ⤴ (シ.Angle(み.⫫, vᖾ) > 10f) ☡̱
        // Update position
        ⮐ Cont(み˙ += vᖾ ᐧ δ);
    }

    //∘ ⑂ Do(⊡ x) { ⌽ } ∘ ⑂ Run(⊡ x) { ☡̱ }

    ┈ Print(⊡ arg) → UnityEngine.Debug.Log(arg);

}}
